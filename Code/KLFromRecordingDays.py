import tkinter as tk
from tkinter import *
import pymysql
import pymysql.cursors
import os
import numpy
import re  # Import the 're' module for regular expressions


# KLFromRecordingDays This application generates KL distance measures between "template day" and "target day" acoustic
# measures generated by Sound Analysis Pro 2011 It was designed to analyze recordings of birds treated with drugs over
# a 20-day period. *.wav files generated by SAP 2011 Recorder over the treatment period are first parsed into
# subdirectories corresponding to day... ...and renamed in the following format: *-##-#####.wav, where * = animal ID,
# ## = recording day, ##### = *.wav file number The parsing and file renaming is done by a separate program called
# "ParseSAPRecorderWavs" ParseSAPRecorderWavs output is then batch processed into segmented syllables using the
# subdirectory option by SAP 2011 The output of SAP 2011 is a MySQL database with an entry for each syllable
# containing 14 acoustic measures: syllable_duration  mean_amplitude	mean_pitch	mean_FM	mean_am2
# mean_entropy	mean_goodness_of_pitch	mean_mean_frequency	var_pitch	var_FM	var_entropy	var_goodness_of_pitch
# var_mean_frequency	var_am The KLFromRecordingDays program allows multiple days to be selected as a "template" in
# our case days 1 - 3 corresponding to pretreatment control recordings The remaining days, in our case 4 - 20 are
# then used as "targets" Virtual 2D plots of syllable duration on x-axes vs. each of the 13 remaining acoustic
# measures as y-axes are generated for the "template" and for each of the "target" days The axes of the plots are
# divided into bins according to the "Axes Divisions" control of the GUI. The default = 15 divisions with 2 axes
# produces 225 bins. Each syllable is assigned to one of these bins and a second 2D probability plot is generated
# Probability plots are used to determine the magnitude of differences between "template" and "target" patterns via
# KL distance measures. KL distance measures for each acoustic parameter for each "target" day are output to an Excel
# spreadsheet in the folder selected by the user via the GUI. The default = "c:\sap\kl_results" Higher KL distance =
# greater magnitude of pattern differences between "template" and "target" acoustic parameters. We have used plots of
# KL distances over time as a measure of recovery from lesions of vocal motor regions. Effects of drugs to reduce
# magnitude of effects and time to recovery can both be determined.


class KLGUI:
    # This is the GUI window that accepts input for KL distance measures
    def __init__(self, master, database_name):  # database = sap the SAP 2011 default MySQL database
        # These are the elements of the GUI
        frame = Frame(master, width=50)
        frame.pack(side=TOP)

        self.master = master
        self.database_name = database_name
        self.host = 'localhost'
        self.user = 'root'
        self.password = 'sap2011'

        topframe = Frame(master)
        topframe.pack(side=TOP)

        self.StatusLabel = Label(root, text="")

        self.FileLabel = Label(topframe, text='Directory to Store Results')
        self.FileLabel.pack(side=TOP)

        self.selected_table = ""

        self.SaveDir = StringVar()
        path = os.path.normpath("c:/sap/kl_results/")  # Default path to store results
        self.SaveDir.set(path)
        self.FileInput = Entry(topframe, width=40)
        self.FileInput["textvariable"] = self.SaveDir
        self.FileInput.pack(side=TOP, padx=5)

        self.FileButton = Button(topframe, text='Change Directory', command=self.ChangeDir)
        self.FileButton.pack(side=TOP, pady=(1, 10))

        midframe = Frame(master)
        midframe.pack(anchor=S)

        self.table_listbox = Listbox(topframe, selectmode=SINGLE, height=5, width=15)
        self.table_listbox.bind("<<ListboxSelect>>", self.on_table_select)
        self.table_listbox.pack(fill="both", expand=True)  # (padx=10, pady=10)

        # Button to select the table
        self.select_button = Button(midframe, text="Select Table", command=self.select_table)
        self.select_button.pack(padx=10, pady=5)

        # Create a Listbox widget for days
        self.day_listbox = Listbox(midframe, selectmode=MULTIPLE, height=5, width=15)
        self.day_listbox.pack(fill="both", expand=True)  # (padx=10, pady=10)

        bottomframe = Frame(master)
        bottomframe.pack(side=BOTTOM)

        self.AxesDivisions = IntVar()  # Determines the number of bins that each axis is divided into
        self.AxesDivisions.set(15)  # Default bins = 15. Given 2 axes the number of cells = 15^2 = 225
        self.AxesScale = Scale(bottomframe, from_=5, to=50, orient=HORIZONTAL, label='Set Axes Divisions',
                               sliderlength=10,
                               length=200, variable=self.AxesDivisions)
        self.AxesScale["variable"] = self.AxesDivisions
        self.AxesScale.pack(side=TOP)

        # If a *.wav file contains fewer than this minimum number of syllables it is not used for KL calculation
        # GUI code to select minimum syllable number for a *.wav to be used
        self.MinSyllPerWav = IntVar()
        self.MinSyllPerWav.set(5)
        self.MinSyllScale = Scale(bottomframe, from_=1, to=10, orient=HORIZONTAL,
                                  label='Set Minimum Syllables/WAV File', sliderlength=10, length=200,
                                  variable=self.MinSyllPerWav)
        self.MinSyllScale.pack(side=TOP)

        # Smoothing factors are used to replace cells with no syllables as the KL distance equation cannot use 0 values
        self.SmoothingFactor = DoubleVar()
        self.SmoothingHolder = IntVar()
        self.SmoothingHolder.set(-6)
        self.SmoothingScale = Scale(bottomframe, from_=-12, to=0, command=self.CalcSmoothFactor, orient=HORIZONTAL,
                                    label='Set KL Smoothing Factor 10^x', sliderlength=10, length=200,
                                    variable=self.SmoothingHolder)
        self.SmoothingScale.pack(side=TOP)

        # Time between prior and proceeding syllables = syllable interval Syllable interval is used to determine the
        # probability that a syllable is part of a motif This can allow most calls and introductory notes to be
        # excluded from the KL distance measure "Filter Out Non-Motif Syllables" determines if a syllable is likely
        # to be part of a motif, modifies the sap... ...MySQL table with a new column designating motif syllable (1)
        # or non-motif syllable (0) and then uses only... ...motif syllables for KL distance measures "Use All
        # Syllables" = Does not use syllable interval to determine motif vs non-motif syllable types and does not...
        # ...modify the sap MySQL table "Use All Syllables And Calculate Type" does use syllable interval to
        # determine motif vs non-motif types and does... ...modify the sap MySQL table with this designation BUT uses
        # all syllables (motif AND non-motif) to measure KL distance
        self.SyllInterval = IntVar()
        self.SyllInterval.set(35)
        self.MotifInterval = Scale(bottomframe, from_=25, to=65, orient=HORIZONTAL,
                                   label='Motif Interval Cutoff (ms)', sliderlength=10, length=200,
                                   variable=self.SyllInterval)
        self.MotifInterval["variable"] = self.SyllInterval
        # GUI to select whether motif vs non-motif are determined and if this is used in KL distance measures
        self.motif = IntVar()
        self.Radio_1 = Radiobutton(bottomframe, text="Use All Syllables", variable=self.motif, value=0,
                                   command=self.MotifChange)
        # Does not distinguish Motif vs. non-Motif syllables
        self.Radio_2 = Radiobutton(bottomframe, text="Filter Out Non-Motif Syllables", variable=self.motif, value=1,
                                   command=self.MotifChange)
        # Only uses Motif syllables for KL calculation
        self.Radio_3 = Radiobutton(bottomframe, text="Calculate Motif-Type but Use All", variable=self.motif, value=2,
                                   command=self.MotifChange)
        # Determines Motif vs. non-Motif syllables, but uses all for KL
        self.Radio_1.pack(anchor=W)
        self.Radio_2.pack(anchor=W)
        self.Radio_3.pack(anchor=W)

        # GUI to launch KL distance analysis
        self.KLButton = Button(bottomframe, text='Run KL', command=self.RunKL, anchor=SE)

        self.MotifInterval.pack(side=TOP)

        self.KLButton.pack(side=RIGHT, padx=(10, 0))  # Pack after MotifInterval to prevent overlap

        # BirdID is taken from the *.wav file format generated by the ParseSAPwavs program that renames *.wav files
        # and places... ...them into seperate recording day subdirectories prior to batch processing by SAP 2011 This
        # is used in the filename for the Excel spreadsheet output
        self.BirdID = ''

        self.motif.set(1)  # Default = "Filter Out Non-Motif Syllables"
        # Status of where the program is in the analysis as it can require hours for large MySQL tables with 100s of
        # thousands of syllables
        self.StatusLabel = Label(bottomframe, text='Running...', justify=RIGHT, fg="red")

        # Get table names
        self.populate_table_listbox()

        self.ListOfDays = []
        self.TemplateListOfDays = []
        self.TargetListOfDays = []

    # Function for convenience that holds names of each of the acoustic parameters analyzed by SAP 2011
    def ParameterList(self):
        Parameters = ['duration', 'mean_amplitude', 'mean_pitch', 'mean_FM', 'mean_am2', 'mean_entropy',
                      'mean_goodness_of_pitch', 'mean_mean_frequency', 'var_pitch', 'var_FM', 'var_entropy',
                      'var_goodness_of_pitch', 'var_mean_frequency', 'var_am']
        return Parameters

    # Function to transform the smooting factor input to a log scale. The function that generates the probability table needs log values
    def CalcSmoothFactor(self, evt):
        self.SmoothingFactor.set(10 ** self.SmoothingHolder.get())

    def select_table(self):
        selected_indices = self.table_listbox.curselection()
        if len(selected_indices) == 0:
            from tkinter import messagebox
            messagebox.showerror("Error", "Please select a table.")
        else:
            selected_index = selected_indices[0]
            self.selected_table = self.table_listbox.get(selected_index)
            print(f"Selected Table: {self.selected_table}")

            # Update button text
            self.select_button.config(text="Select Day(s) to Use as Template", command=self.select_template_days)

            # Clear previous days in the day listbox
            self.day_listbox.delete(0, END)

            # Repopulate the day listbox with days associated with the newly selected table
            self.populate_day_listbox(self.selected_table)

    # Function if table selection changes
    def on_table_select(self, event):
        # Get the selected table index
        selected_index = self.table_listbox.curselection()
        if selected_index:
            self.selected_table = self.table_listbox.get(selected_index[0])
            print(f"Selected Table: {self.selected_table}")

            # Clear previous days in the day listbox
            self.day_listbox.delete(0, END)

            # Repopulate the day listbox with days associated with the newly selected table
            self.populate_day_listbox(self.selected_table)

            # Change button text
            self.select_button.config(text="Select Day(s) to Use as Template", command=self.select_template_days)

    def populate_table_listbox(self):
        table_names = self.get_table_names()
        for table_name in table_names:
            self.table_listbox.insert(END, table_name)

    def get_table_names(self):
        try:
            # Establish a connection to the MySQL database
            connection = pymysql.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                database=self.database_name
            )

            # Create a cursor object
            cursor = connection.cursor()

            # Execute the query to get the list of tables
            query = """SHOW TABLES LIKE %s"""
            cursor.execute(query, (('%' + 'syll' + '%',)))

            # Fetch all the results
            tables = cursor.fetchall()

            # Close the cursor and connection
            cursor.close()
            connection.close()

            # Extract table names from the result
            table_names = [table[0] for table in tables]

            return table_names

        except pymysql.MySQLError as e:
            print(f"Error: {e}")
            return []

    def populate_day_listbox(self, table_name):
        cursor = None  # Initialize cursor to None
        conn = None  # Initialize conn to None
        try:
            self.day_listbox.delete(0, END)  # Clear previous data

            conn = pymysql.connect(host=self.host, port=3306, user=self.user, passwd=self.password,
                                   db=self.database_name)
            cursor = conn.cursor()
            query = f"""
                SELECT DISTINCT SUBSTRING(file_name, LOCATE('_', file_name) + 1, 2) AS file_prefix FROM {table_name}
                ORDER BY file_prefix;
                """
            cursor.execute(query)
            print("Query executed successfully.")

            for dayval in cursor.fetchall():
                day = dayval[0]
                if day:  # Check if day_name exists
                    self.day_listbox.insert(END, day)
                    self.ListOfDays.append(day)

            print("Processed results successfully.")
            # This is to get BirdID
            # SQL query to retrieve a single row
            query = "SELECT recnum, file_name FROM " + table_name + " LIMIT 1"

            # Execute the query
            cursor.execute(query)

            # Fetch the single row
            row = cursor.fetchone()

            # Print the result
            if row:
                recnum, file_name = row
                print(f"recnum: {recnum}, file_name: {file_name}")
                self.BirdID = self.birdid(file_name)
            else:
                print("No rows found")

        except pymysql.MySQLError as e:
            print(f"Error: {e}")
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    # TemplateListOfDays has been generated. This assigns remaining days to TargetListOfDays
    def CreateTargetListOfDays(self):
        self.TargetListOfDays = []
        for i in self.ListOfDays:
            if i not in self.TemplateListOfDays:
                self.TargetListOfDays.append(i)

    def select_template_days(self):
        selected_indices = self.day_listbox.curselection()
        self.TemplateListOfDays = [self.day_listbox.get(idx) for idx in selected_indices]
        print("Template Days:", self.TemplateListOfDays)
        self.CreateTargetListOfDays()
        print("Target Days:", self.TargetListOfDays)

    # Function to extract BirdID from the *.wav filename in the format generated by ParseSAPwavs
    def birdid(self, filename):  # FileName must be in *_##_#### format w/Bird ID = *
        # import re
        pattern = r'^(.*)_\d{2}_\d{5}\.wav$'
        # Match the patternf
        match = re.match(pattern, filename)
        # Check if the pattern matches and extract the part before the first underscore
        if match:
            variable_part = match.group(1)
            self.BirdID = variable_part
            return variable_part
        else:
            raise ValueError("Filename does not match the expected format")

    # Function to extract recording day information from the *.wav filename in the format generated by ParseSAPwavs
    def IsolateDay(self, filenames):
        for filename in filenames:
            # Define the regular expression pattern
            pattern = r'^.*_(\d{2})_\d{5}\.wav$'

            # Match the pattern
            match = re.match(pattern, filename)

            if match:
                day_str = match.group(1)
                return day_str
            else:
                raise ValueError(f"Underscore not found in filename: {filename}")

        return None

    # Code that shows or hides syllable interval selection on the GUI depending on if it is used for KL distance measures
    def MotifChange(self):
        button = self.motif.get()
        if button == 1 or 2:
            self.MotifInterval.pack(side=TOP)
        else:
            self.MotifInterval.pack_forget()
        return self.motif.get()

    # Code to assing a new output path to save Excel file results in if it is changed in the GUI
    def ChangeDir(self):
        self.StatusLabel.pack_forget()
        from tkinter import filedialog
        path = filedialog.askdirectory()
        self.FileInput.delete(0, END)
        self.FileInput.insert(0, path)

    # Creates a dictionary of values taken from GUI input. This dictionary is used by the mainKL procedure launched by the RunKL button on the GUI
    def BundleVars(self):
        vars = {'FileDirectory': os.path.normpath(self.SaveDir.get()), 'TableToUse': self.selected_table,
                'TemplateDays': self.TemplateListOfDays, 'TargetDays': self.TargetListOfDays, 'BirdID': self.BirdID,
                'AxesDivisions': self.AxesDivisions.get(),
                'OnlyMotifs': self.motif.get(), 'SyllInterval': self.MotifInterval.get(),
                'MinSyllPerWav': self.MinSyllPerWav.get(), 'SmoothingFactor': self.SmoothingFactor.get()
                }
        return vars

    # The main procedure launched by the RunKL GUI button
    def RunKL(self):
        # If smoothing factor isn't set, set it to default
        if self.SmoothingFactor.get() == 0:
            self.SmoothingFactor.set(10 ** -6)
        # Notification to user that the application is running
        self.StatusLabel.config(text='Running...')
        self.StatusLabel.pack(side=BOTTOM)
        self.StatusLabel.update()
        # Creates the BundleVars dictionary to pass to mainKL
        Vars = self.BundleVars()
        # The main procedure that caluclates KL distances between template days and each target day
        mainKL(Vars)
        # Notification to user that the analysis is complete
        self.StatusLabel.config(text='Done')


# Main function
def mainKL(Inputvars):
    # No table selected in GUI
    if Inputvars.get('TableToUse') == None:
        from tkinter import messagebox
        entertable = messagebox.showinfo("SAP Table Not Selected", "Select SAP Table")
        return
    # No template days selected in GUI
    if len(Inputvars.get('TemplateDays')) == 0:
        from tkinter import messagebox
        entertemplate = messagebox.showinfo("Template Not Selected", "Select Template")
        return

    ModifyTableWithDay(Inputvars.get('TableToUse', None))  # Adds rec_day to selected table in the sap MySQL database

    if Inputvars.get('OnlyMotifs'):  # Indicated in GUI, could be 1 = Only Motifs or 2 = Use All And Calc Syl Type
        # Calls function to calculate
        Syll_Duration(Inputvars.get("TableToUse"), Inputvars.get("SyllInterval"),
                      Inputvars.get("MinSyllPerWav"))  # Adds pre/post interval and syllable type(motif v non-motif)

    # Calls a function to create a new MySQL table that is a subset of the sap table selected by the GUI...
    # ...that includes the subset of data corresponding to the days selected to be used as the Template
    MakeTemplateTable(Inputvars.get("TableToUse", None),
                      Inputvars.get("TemplateDays", None),
                      Inputvars.get("OnlyMotifs", None))  # Creates table 'TEMPLATE'

    # Calls a function to create a new MySQL table of only Target day data
    MakeTargetTable(Inputvars.get("TableToUse", None),
                    Inputvars.get("TargetDays", None),
                    Inputvars.get("OnlyMotifs", None))  # Creates table 'TARGET'

    # A list of SAP 2011 parameters for convenience
    paramlist = ['duration', 'mean_amplitude', 'mean_pitch', 'mean_FM', 'mean_am2', 'mean_entropy',
                 'mean_goodness_of_pitch', 'mean_mean_frequency', 'var_pitch', 'var_FM', 'var_entropy',
                 'var_goodness_of_pitch', 'var_mean_frequency', 'var_am']

    # A function that takes the Target Table and seperates each day of data into a separate Target Day Table
    CreateTargetDayTables('TARGET', Inputvars.get("TargetDays", None))

    XTxt = paramlist[0]  # 'duration'
    TempX = TableParameters('TEMPLATE',
                            XTxt)  # Creates a dictionary of values for Duration (always the x-axis parameter) from the Template MySQL table
    KLResults = {}
    workday = 0
    # For each of the days in the TargetDays key of Inputvars, i.e. for each of the non-template days
    for recday in Inputvars.get('TargetDays'):
        workday = workday + 1
        NoticeText = "Calculating KL for day " + str(workday) + " of " + str(len(Inputvars.get('TargetDays')))
        window.StatusLabel.config(text=NoticeText)
        window.StatusLabel.update()
        # A dictionary to collect KL values for each acoustic parameter except Syllable Duration (that is always the x-axis
        KLPerParam = {}

        TargetX = {}  # To prevent reference before initialization
        GotTargetX = False  # Boolen switch so that TargetX only runs TableParameters once as x-axis is always Syllable Duration

        # For each of the acoustic parameters...
        for YTxt in paramlist:
            # Except for duration that is always the x-axis
            if not YTxt == 'duration':
                # If the x-axis 'duration' table has not been created yet
                if not GotTargetX:
                    TargetX = TableParameters('TARGETDAY_' + str(recday), XTxt)
                    GotTargetX = True
                # Make the y-axis table for current YTxt from paramlist
                # Creates a dictionary of values from the YTxt acoustic feature...
                # ...From the Template table
                TempY = TableParameters('TEMPLATE', YTxt)
                # ...From the current target day (recday) table
                TargetY = TableParameters('TARGETDAY_' + str(recday), YTxt)

                # Creates a GenerateKL object for the current acoustic parameter between Template and TargetDay (recday) tables
                KL = GenerateKL(TempX[XTxt], TempY[YTxt], TargetX[XTxt], TargetY[YTxt], Inputvars.get("AxesDivisions"),
                                Inputvars.get("SmoothingFactor"))
                # Gets the KL distance measure for the current acoustic parameter between Template and TargetDay (recday) tables from the GenerateKL object
                KLPerParam[YTxt] = KL.Get_KLDistance()
        # Adds the KL Distance measure results for the current acoustic parameter and day to the KLResults dictionary
        KLResults[recday] = KLPerParam
        # Loops to the next acoustic parameter for the Target day
        # Unless it has completed the last in which case it goes to the next Target day and starts with 'mean_amplitude'

    # KL distances for all parameters for all Target days have been calculated
    # Now save KL distance data to an Excel spreadsheet in the FileDirectory specified by the GUI
    WriteXL(Inputvars.get("FileDirectory"), KLResults,
            Inputvars.get("TemplateDays"), Inputvars.get("TargetDays"), Inputvars.get("BirdID"),
            Inputvars.get("AxesDivisions"), Inputvars.get("MinSyllPerWav"), Inputvars.get("OnlyMotifs"),
            Inputvars.get("SyllInterval"), Inputvars.get("SmoothingFactor"), Inputvars.get("TableToUse"))

    NoticeText = "Cleaning-up tables..."

    window.StatusLabel.config(text=NoticeText)
    window.StatusLabel.update()

    # Call function to delete Template, Target, TargetDay and other temporary MySQL tables
    ClearTables(Inputvars.get("TargetDays"), Inputvars.get("TableToUse"))
    return


# Function that adds the recording day to each syllable in a sap MySQL table
def ModifyTableWithDay(TableName):
    conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
    cursor = conn.cursor()

    NoticeText = "Calculating Recording Days..."
    window.StatusLabel.config(text=NoticeText)
    window.StatusLabel.update()

    query = "DROP TABLE IF EXISTS RECDAY"
    cursor.execute(query)

    size = 1000
    lastid = 0
    UpdateList = []
    while True:
        query = "SELECT recnum, file_name FROM " + TableName + " WHERE recnum > " + str(
            lastid) + " ORDER BY recnum LIMIT " + str(size)
        cursor.execute(query)

        rows = cursor.fetchall()

        if not rows:
            break
        for row in rows:
            day = int(window.IsolateDay([row[1], ]))
            UpdateList.append([row[0], day])  # recnum, day
            lastid = row[0]

    # Create table w/recnum and rec_day
    query = "CREATE TABLE RECDAY(recnum INT(11) PRIMARY KEY, rec_day INT(4))"
    cursor.execute(query)

    query = "create index rec_day on RECDAY (rec_day)"
    cursor.execute(query)

    query = "SELECT * FROM " + TableName + " LIMIT 1"
    cursor.execute(query)
    field_names = [i[0] for i in
                   cursor.description]  # get list of field names to know if preint, postint, syll_type need to be added
    if 'rec_day' in field_names:
        query = "ALTER TABLE " + TableName + " DROP rec_day"
        cursor.execute(query)

    query = "ALTER TABLE " + TableName + " ADD rec_day INT(4)"
    cursor.execute(query)

    query = "INSERT INTO RECDAY(recnum, rec_day) VALUES (%s, %s)"
    cursor.executemany(query, UpdateList)
    conn.commit()

    query = "create index rec_day on " + TableName + " (rec_day)"
    cursor.execute(query)

    query = "UPDATE " + TableName + " AS t1 INNER JOIN RECDAY AS t2 ON t1.recnum = t2.recnum SET t1.rec_day = t2.rec_day"
    cursor.execute(query)
    conn.commit()

    query = "drop index rec_day on " + TableName
    cursor.execute(query)

    cursor.close()
    conn.close()


# Creates a dictionary of values for a particular acoustic parameter from a particular MySQL table
def TableParameters(tablename, parameter):
    ParamRes = []
    ParamDict = {}

    conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
    cur = conn.cursor()

    query = "create index " + parameter + " ON " + tablename + " (" + parameter + ")"
    cur.execute(query)

    query = "create index recnum ON " + tablename + " (recnum)"
    cur.execute(query)

    query = "SELECT recnum, " + parameter + " FROM " + tablename + " ORDER BY recnum"
    cur.execute(query)

    for i in range(0, cur.rowcount):
        res = cur.fetchone()
        ParamRes.append(res[1])

    ParamDict[parameter] = ParamRes

    query = "drop index " + parameter + " ON " + tablename
    cur.execute(query)

    query = "drop index recnum ON " + tablename
    cur.execute(query)

    cur.close()
    conn.close()

    return ParamDict


# Class that parses Target table data in to seperate tables for each day recordings were made
class CreateTargetDayTables:  # This seperates TARGET table into days. TEMPLATE is already single/combination to be used as one
    def __init__(self, TargetTable, ListOfDays):
        self.maketables(ListOfDays, TargetTable)

        NoticeText = "Creating Target Day Tables..."
        window.StatusLabel.config(text=NoticeText)
        window.StatusLabel.update()

    def maketables(self, ListOfDays, TargetTable):
        # Creates a MySQL table for each day
        conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
        cur = conn.cursor()

        query = "create index rec_day ON " + TargetTable + " (rec_day)"
        cur.execute(query)

        for i in ListOfDays:
            text = "TARGETDAY_" + str(i)
            query = "DROP TABLE IF EXISTS " + text
            cur.execute(query)

            query = "CREATE TABLE " + text + " SELECT * FROM " + TargetTable + " WHERE rec_day = " + str(i)
            cur.execute(query)
            conn.commit()

            query = "alter table " + text + " add primary key (recnum)"
            cur.execute(query)

        query = "drop index rec_day ON " + TargetTable
        cur.execute(query)
        conn.close()
        cur.close()


# Encapsulated class that generates probability tables for Template and a Target day and uses
# these 2D arrays for KL distance measures for an acoustic parameter
class GenerateKL:
    def __init__(self, TempX, TempY, TargetX, TargetY, axediv, SmoothFactor):
        # Establishes min and max values for Template and Target
        # These are used to define the range of the axes values that will be divided into
        # axediv number of bins
        # Axes bins will be used to generate a 2D array of cells = axediv^2
        # For default axediv = 15, the number of 2D array cells = 225
        maxy = max(max(TempY), max(TargetY))
        miny = min(min(TempY), min(TargetY))
        maxx = max(max(TempX), max(TargetX))
        minx = min(min(TempX), min(TargetX))

        # The numpy procedure histogram2d is used to generate Template and Target incidence
        # distributions
        # Each incidence represents a syllable that falls into a cell of the 2D array
        # Note this histogram2d normed was depricated.
        self.TemplateArray, TempXEdge, TempYEdge = numpy.histogram2d(TempX, TempY, bins= \
            axediv, range=[[minx, maxx], [miny, maxy]], density=False)  # axediv x axediv array
        #  w/counts of sylls
        self.TargetArray, TargetXEdge, TargetYEdge = numpy.histogram2d(TargetX, TargetY,
                                                                       axediv, range=[[minx, maxx], [miny, maxy]],
                                                                       density=False)

        # To each cell of the 2D Template and Target incidence distributions is added
        # a smoothing factor.
        # The magnitude of the smoothing factor can be controlled by the user through the GUI.
        # Default = 10^-6
        # A smoothing factor is necessary as the KL distance equation uses probability
        # distribution factors as denominators
        self.TemplateArray = [(x + SmoothFactor) for x in self.Get_TemplateArray()]
        self.TargetArray = [(x + SmoothFactor) for x in self.Get_TargetArray()]

        # Incidence distributions are converted to probability distributions where the sum
        # of all cells of the 2D distribution = 1
        self.TemplateProbs = [x / sum(sum(self.Get_TemplateArray())) for x in \
                              self.Get_TemplateArray()]
        self.TargetProbs = [x / sum(sum(self.Get_TargetArray())) for x in \
                            self.Get_TargetArray()]

        # Probability distributions are then passed to a function that calculates KL distance
        self.KL = self.KLCalc(self.TemplateProbs, self.TargetProbs, axediv)

    # Get function passes the TemplateArray from the GenerateKL object
    def Get_TemplateArray(self):
        return self.TemplateArray

    # Get function passes the TargetArray from the GenerateKL object
    def Get_TargetArray(self):
        return self.TargetArray

    # Get function passes the KL distance measure from the GenerateKL object
    def Get_KLDistance(self):
        return self.KL

    # This function uses Template and Target arrays to calculate KL distance
    # This gives results identical to the scipy.stats.entropy function
    # This measure was first applied to evaluating differences in acoustic features by...
    # Wu W, Thompson JA, Bertram R, Johnson F. J Neurosci Methods. 2008 Sep 15;174(1):147-54
    # http://www.sciencedirect.com/science/article/pii/S0165027008003907
    def KLCalc(self, TemplateArray, TargetArray, AxesDiv):
        import math
        SumMN = 0
        for i in range(AxesDiv):
            for j in range(AxesDiv):
                q_1 = TemplateArray[i][j]
                q_k = TargetArray[i][j]
                qratio = q_1 / q_k
                if qratio == 0:
                    SumMN = SumMN
                else:
                    SumMN = SumMN + (q_1 * math.log(qratio, 2))

        KLDistance = SumMN
        return KLDistance


# Function to clean up temporary tables created

def ClearTables(daylist, saptable):
    # Prepare the initial part of the crit string
    text = "TARGETDAY_"

    # Use a set to store unique table names
    unique_tables = set()

    # Add tables from daylist to the set
    for day in daylist:
        unique_tables.add(text + str(day))

    # Add other fixed table names
    additional_tables = ["TARGET", "TEMPLATE", "RECDAY", "SERNUMS", saptable[5:] + "_SYLDUR"]
    unique_tables.update(additional_tables)

    # Join the unique table names into a single string separated by commas
    crit = ", ".join(unique_tables)

    # Construct the DROP TABLE query
    query = f"DROP TABLE IF EXISTS {crit}"

    # Execute the query
    conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
    cur = conn.cursor()
    cur.execute(query)
    conn.close()
    cur.close()


# Function to create an Excel spreadsheet and write KL distance measure results
def WriteXL(Path, KLResults, TemplateDays, TargetDays, BirdID, axdiv, minsyl, syltype, sylinterval, smoothingfactor,
            TableName):
    import os
    import openpyxl as xl

    StartDir = os.path.normpath(Path)
    KLDir = "kl_results"
    if StartDir.find(KLDir) < 1:
        KLDir = "\kl_results"
        os.makedirs(Path + KLDir, exist_ok=True)
        StartDir = Path + KLDir
    else:
        os.makedirs(StartDir, exist_ok=True)
    os.chdir(StartDir)

    wb = xl.Workbook()
    ws = wb.active

    ws.title = "KL Results Summary"
    ws['B4'] = 'Day#'
    TemplateText = 'Day(s) used for template: '
    TempDays = ''
    for Day in TemplateDays:
        TempDays = TempDays + str(Day) + "_ "
    TemplateText = TemplateText + TempDays
    TemplateText = TemplateText[:-2]
    ws['A1'] = 'Bird = ' + BirdID
    ws['A2'] = TemplateText

    ParameterList = ['mean_amplitude', 'mean_pitch', 'mean_FM', 'mean_am2', 'mean_entropy', 'mean_goodness_of_pitch',
                     'mean_mean_frequency', 'var_pitch', 'var_FM', 'var_entropy', 'var_goodness_of_pitch',
                     'var_mean_frequency', 'var_am']
    ParameterDict = {'mean_amplitude': 1, 'mean_pitch': 2, 'mean_FM': 3, 'mean_am2': 4, 'mean_entropy': 5,
                     'mean_goodness_of_pitch': 6, 'mean_mean_frequency': 7, 'var_pitch': 8, 'var_FM': 9,
                     'var_entropy': 10, 'var_goodness_of_pitch': 11, 'var_mean_frequency': 12, 'var_am': 13}
    col = 3
    for Param in ParameterList:
        ws.cell(row=4, column=ParameterDict[Param] + 2, value=Param)

    currow = 5
    workday = 0
    for day in sorted(TargetDays):
        workday = workday + 1
        NoticeText = "Writing XL output for day " + str(workday) + " of " + str(len(TargetDays))
        window.StatusLabel.config(text=NoticeText)
        window.StatusLabel.update()

        ws.cell(row=currow, column=2, value=day)

        for Param in ParameterList:
            result = KLResults[day][Param]
            col = ParameterDict[Param] + 2
            ws.cell(row=currow, column=col, value=result)
        currow = currow + 1

    if syltype == 1:
        syltext = 'only motifs, ' + str(sylinterval) + ' ms interval'
    else:
        syltext = 'all syllables'

    ws["P4"] = 'Mean KL'
    for currow in range(5, len(TargetDays) + 5):
        start = "C" + str(currow)
        finish = "O" + str(currow)
        equation = "=AVERAGE(" + start + ":" + finish + ")"
        ws.cell(row=currow, column=16, value=equation)

    SyllDict = SyllablesPerDay(TableName, TemplateDays, TargetDays, syltype)

    if syltype == 1:
        TempSyllText = ''
        for day in TemplateDays:
            TempSyllText = TempSyllText + "Day " + str(day) + ": " + str(SyllDict[day][0]) + " total, " + str(
                SyllDict[day][1]) + " motif, "
        ws["D2"] = TempSyllText[:-1]

        ws["Q4"] = "Total Syllables"
        ws["R4"] = "Motif Syllables"
    else:
        TempSyllText = ''
        for day in TemplateDays:
            TempSyllText = TempSyllText + "Day " + str(day) + ": " + str(SyllDict[day][0]) + " total syllables; "

        ws["D2"] = TempSyllText[:-2]

        ws["Q4"] = "Total Syllables"

    currow = 5
    for day in TargetDays:
        ws.cell(row=currow, column=17, value=SyllDict[day][0])
        if syltype == 1:
            ws.cell(row=currow, column=18, value=SyllDict[day][1])
        currow = currow + 1

    ValString = str(axdiv) + " axes divisions, " + str(smoothingfactor) + " smoothing factor, " + str(
        minsyl) + " syllables/wav minimum , " + syltext

    ws["D1"] = ValString

    DayStr = (BirdID + "_" + TempDays + "tmp_" + str(len(TargetDays)) + "_trg.xlsx")

    try:
        wb.save(DayStr)
    except PermissionError:
        from tkinter import messagebox
        messagebox.showinfo("Before closing this message MAKE SURE to close " + DayStr, DayStr + " Already Open")

    return


# Function that calculates presyllable and postsyllable intervals for each syllable in the specified sap MySQL table
# Intervals are used to predict whether or not each syllable is part of a motif
# The sap MySQL table is modified to include preinterval and postinterval data and whether each syllable is predicted...
# ...to be part of a motif or not
def Syll_Duration(table_name, sylldurcrit, minsylls):
    SerNums = GetSerNums(
        table_name)  # Returns list of [serial_number, syllable count] that correspond to single wav files
    conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
    cursor = conn.cursor()

    NoticeText = "Parsing Motif vs. Non-Motif syllables..."
    window.StatusLabel.config(text=NoticeText)
    window.StatusLabel.update()

    query = "DROP TABLE IF EXISTS " + table_name[5:] + "_SYLDUR"
    cursor.execute(query)

    query = "create index serial_number ON " + table_name + " (serial_number)"
    cursor.execute(query)

    query = "CREATE TABLE " + table_name[
                              5:] + "_SYLDUR(recnum INT(11) PRIMARY KEY, preint FLOAT, postint FLOAT, syll_type BIT)"
    cursor.execute(query)
    linenum = 1
    for line in SerNums:  # serial_num, Number of syllables
        NoticeText = "Parsing Motif vs. Non-Motif syllables file " + str(linenum) + " of " + str(len(SerNums))
        window.StatusLabel.config(text=NoticeText)
        window.StatusLabel.update()
        query = "SELECT recnum, serial_number, start_on, duration FROM " + table_name + " WHERE serial_number = " + str(
            line[0]) + " ORDER BY recnum"
        cursor.execute(query)
        wavres = [X for X in cursor.fetchall()]
        # recnum =0, serial_number = 1, start_on = 2, duration = 3             NOT ANYMORE             preint = 5, postint = 6, syll_type = 7
        syldurvals = []

        if len(wavres) > 2:  # Some files have 1 syllable. Throws an error.
            for i in range(0, len(wavres)):
                my_recnum = wavres[i][0]
                if i == 0 or i == len(wavres) - 1:
                    if i == 0:
                        my_postint = wavres[i + 1][2] - (wavres[i][2] + wavres[i][3])
                        if my_postint < sylldurcrit and line[1] >= minsylls:
                            my_syll_type = 1
                        else:
                            my_syll_type = 0
                        syldurvals.append((my_recnum, None, my_postint, my_syll_type))
                    else:
                        my_preint = wavres[i][2] - (wavres[i - 1][2] + wavres[i - 1][3])
                        if my_preint < sylldurcrit:
                            my_syll_type = 1
                        else:
                            my_syll_type = 0
                        syldurvals.append((my_recnum, my_preint, None, my_syll_type))
                else:
                    my_postint = wavres[i + 1][2] - (wavres[i][2] + wavres[i][3])
                    my_preint = wavres[i][2] - (wavres[i - 1][2] + wavres[i - 1][3])
                    if (my_preint < sylldurcrit or my_postint < sylldurcrit) and line[1] >= minsylls:
                        my_syll_type = 1
                    else:
                        my_syll_type = 0
                    syldurvals.append((my_recnum, my_preint, my_postint, my_syll_type))

            query = "INSERT INTO " + table_name[
                                     5:] + "_SYLDUR (recnum, preint, postint, syll_type) VALUES (%s, %s, %s, %s)"
            cursor.executemany(query, syldurvals)
            conn.commit()
            linenum = linenum + 1
    # table_name_SYLDUR will not be in recnum order
    query = "drop index serial_number ON " + table_name
    cursor.execute(query)
    cursor.close()
    conn.close()


# Function to count the number of syllables used for KL distance measures for each Target day
def SyllablesPerDay(TableName, TemplateDays, TargetDays, OnlyMotifs):
    conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
    cursor = conn.cursor()
    motifsyllables = 0
    SyllableDict = {}

    for day in TemplateDays:
        query = "SELECT recnum from " + TableName + " WHERE rec_day = " + str(day)
        cursor.execute(query)
        totalsyllables = cursor.rowcount
        if OnlyMotifs == 1:
            query = "SELECT recnum from " + TableName + " WHERE rec_day = " + str(day) + " AND syll_type = 1"
            cursor.execute(query)
            motifsyllables = cursor.rowcount

        SyllableDict[day] = (totalsyllables, motifsyllables)

    for day in TargetDays:
        query = "SELECT recnum from " + TableName + " WHERE rec_day = " + str(day)
        cursor.execute(query)
        totalsyllables = cursor.rowcount

        if OnlyMotifs == 1:
            query = "SELECT recnum from " + TableName + " WHERE rec_day = " + str(day) + " AND syll_type = 1"
            cursor.execute(query)
            motifsyllables = cursor.rowcount

        SyllableDict[day] = (totalsyllables, motifsyllables)

    return SyllableDict


# Functions to extract the serial number assigned to each syllable by SAP 2011
def GetSerNums(table_name):
    conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap',
                           cursorclass=pymysql.cursors.SSCursor)
    cursor = conn.cursor()

    NoticeText = "Grouping Recording Days..."
    window.StatusLabel.config(text=NoticeText)
    window.StatusLabel.update()

    query = "DROP TABLE IF EXISTS SERNUMS"
    cursor.execute(query)

    query = "CREATE TABLE SERNUMS SELECT serial_number, COUNT(1) AS SerCount FROM " + table_name + " GROUP BY serial_number"
    cursor.execute(query)

    query = "SELECT * FROM SERNUMS ORDER BY serial_number"
    cursor.execute(query)

    res = cursor.fetchall()
    # SerNums = [[i[0], i[1]] for i in res]
    SerNums = []
    for row in res:
        # print(row)
        SerNums.append([row[0], row[1]])

    cursor.close()
    conn.close()

    return SerNums


# Function to extract the subset of data for the recording days specified to be used as a Template by the GUI
# Depending upon GUI entry for motif types to be used for analysis (OnlyMotifs) it will modify the Template MySQL table to...
# include the syllable type column or not
def MakeTemplateTable(TableName, TemplateDayList, OnlyMotifs):
    NoticeText = "Making Template Table..."
    window.StatusLabel.config(text=NoticeText)
    window.StatusLabel.update()

    if TemplateDayList and TableName:
        query = "DROP TABLE IF EXISTS TEMPLATE"
        conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
        cursor = conn.cursor()
        cursor.execute(query)

        query = "SELECT * FROM " + TableName + " LIMIT 1"
        cursor.execute(query)
        field_names = [i[0] for i in
                       cursor.description]  # get list of field names to know if preint, postint, syll_type need to be added
        if 'preint' in field_names:
            query = "ALTER TABLE " + TableName + " DROP preint, DROP postint, DROP syll_type"
            cursor.execute(query)

        crit = ''
        DayList = TemplateDayList
        for Day in DayList:
            crit = crit + "rec_day = " + str(Day) + " OR "
        crit = crit[:-4]

        crit = "CREATE TABLE TEMPLATE SELECT * FROM " + TableName + " WHERE (" + crit + ") ORDER BY recnum"

        if OnlyMotifs != 0:
            crit = crit[:-17]

            if OnlyMotifs == 1:
                crit = crit + " AND syll_type = 1)"

            if OnlyMotifs == 2:
                crit = crit + ")"

            query = "ALTER TABLE " + TableName + " ADD(preint FLOAT, postint FLOAT, syll_type BIT)"
            cursor.execute(query)

            query = "UPDATE " + TableName + " AS t1 INNER JOIN " + TableName[
                                                                   5:] + "_SYLDUR AS t2 ON t1.recnum = t2.recnum SET t1.preint = t2.preint, t1.postint = t2.postint, t1.syll_type = t2.syll_type"
            cursor.execute(query)

            crit = crit + " ORDER BY recnum"
            cursor.execute(crit)
            conn.commit()
        else:
            cursor.execute(crit)
            conn.commit()

        query = "alter table template add primary key (recnum)"
        cursor.execute(query)

        cursor.close()
        conn.close()
    else:
        x = 'error'
    return


# Makes a Target table including all target days
# May also include syllable type information
# This inclusive Target table will be separated into multiple tables by recording day for KL distance measures
def MakeTargetTable(TableName, TargetDayList, OnlyMotifs):
    NoticeText = "Making Target Table..."
    window.StatusLabel.config(text=NoticeText)
    window.StatusLabel.update()

    if TargetDayList and TableName:
        query = "DROP TABLE IF EXISTS TARGET"
        conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='sap2011', db='sap')
        cursor = conn.cursor()
        cursor.execute(query)

        query = "SELECT * FROM " + TableName + " LIMIT 1"
        cursor.execute(query)
        field_names = [i[0] for i in
                       cursor.description]  # get list of field names to know if preint, postint, syll_type need to be added
        if 'preint' in field_names:
            query = "ALTER TABLE " + TableName + " DROP preint, DROP postint, DROP syll_type"
            cursor.execute(query)

        crit = ''
        DayList = TargetDayList
        for Day in DayList:
            crit = crit + "rec_day = " + str(Day) + " OR "
        crit = crit[:-4]

        crit = "CREATE TABLE TARGET SELECT * FROM " + TableName + " WHERE (" + crit + ") ORDER BY recnum"

        if OnlyMotifs != 0:
            crit = crit[:-17]

            if OnlyMotifs == 1:
                crit = crit + " AND syll_type = 1)"

            if OnlyMotifs == 2:
                crit = crit + ")"

            query = "ALTER TABLE " + TableName + " ADD(preint FLOAT, postint FLOAT, syll_type BIT)"
            cursor.execute(query)

            query = "UPDATE " + TableName + " AS t1 INNER JOIN " + TableName[
                                                                   5:] + "_SYLDUR AS t2 ON t1.recnum = t2.recnum SET t1.preint = t2.preint, t1.postint = t2.postint, t1.syll_type = t2.syll_type"
            cursor.execute(query)

            crit = crit + " ORDER BY recnum"
            cursor.execute(crit)
            conn.commit()
        else:
            cursor.execute(crit)
            conn.commit()

        query = "alter table TARGET add primary key (recnum)"
        cursor.execute(query)

        cursor.close()
        conn.close()
    else:
        x = 'error'
    return


# This is a Tkinter GUI program
if __name__ == '__main__':
    root = tk.Tk()
    root.title("KLFromRecordingDays")
    # Calls the GUI
    window = KLGUI(root, database_name='sap')
    # Infinite loop while the GUI is active
    root.mainloop()
